//! Instructions to craft items.

use crate::asset_management::manifest::loader::IsRawManifest;
use crate::asset_management::manifest::{Id, Manifest};
use crate::items::item_manifest::{Item, ItemManifest};
use crate::items::{inventory::Inventory, ItemCount};
use crate::{
    crafting::{InputInventory, OutputInventory},
    organisms::energy::Energy,
    simulation::light::{Illuminance, TotalLight},
};
use bevy::reflect::{FromReflect, Reflect, TypeUuid};
use bevy::utils::HashMap;
use serde::{Deserialize, Serialize};
use std::{fmt::Display, time::Duration};

/// The marker type for [`Id<Recipe>`](super::Id).
#[derive(Reflect, FromReflect, Clone, Copy, PartialEq, Eq)]
pub struct Recipe;

/// Stores the read-only definitions for all recipes.
pub type RecipeManifest = Manifest<Recipe, RecipeData>;

/// A recipe to turn a set of items into different items.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RecipeData {
    /// The inputs needed to craft the recipe.
    pub inputs: Vec<ItemCount>,

    /// The outputs generated by crafting.
    pub outputs: RecipeOutput,

    /// The time needed to craft the recipe.
    pub craft_time: Duration,

    /// The conditions that must be met to craft the recipe.
    pub conditions: RecipeConditions,

    /// The amount of [`Energy`] produced by making this recipe, if any.
    ///
    /// This is only relevant to living structures.
    pub energy: Option<Energy>,
}

/// The items produced by a recipe.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum RecipeOutput {
    /// The recipe produces a fixed number of each output.
    Deterministic(Vec<ItemCount>),
    /// The recipe produces a random number of each output.
    Stochastic(Vec<(Id<Item>, f32)>),
}

impl RecipeOutput {
    /// Convert the raw data into a [`RecipeOutput`].
    ///
    /// If all the counts are integers, then the recipe is deterministic.
    /// Otherwise, it is stochastic.
    fn from_raw(raw_data: HashMap<String, f32>) -> Self {
        let all_integers = raw_data.values().all(|count| count.fract() == 0.0);

        match all_integers {
            true => Self::Deterministic(
                raw_data
                    .into_iter()
                    .map(|(item_name, count)| ItemCount {
                        item_id: Id::from_name(item_name),
                        count: count as usize,
                    })
                    .collect(),
            ),
            false => Self::Stochastic(
                raw_data
                    .into_iter()
                    .map(|(item_name, count)| (Id::from_name(item_name), count))
                    .collect(),
            ),
        }
    }

    /// The number of outputs produced by this recipe.
    pub fn len(&self) -> usize {
        match self {
            Self::Deterministic(outputs) => outputs.len(),
            Self::Stochastic(outputs) => outputs.len(),
        }
    }

    /// Are there any outputs produced by this recipe?
    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    /// The [`Id<Item>`]s of the items produced by this recipe.
    pub fn item_ids(&self) -> Vec<Id<Item>> {
        match self {
            Self::Deterministic(outputs) => outputs.iter().map(|output| output.item_id).collect(),
            Self::Stochastic(outputs) => outputs.iter().map(|(item_id, _)| *item_id).collect(),
        }
    }
}

/// The unprocessed equivalent of [`RecipeData`].
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RawRecipeData {
    /// The inputs needed to craft the recipe.
    pub inputs: HashMap<String, usize>,

    /// The outputs generated by crafting.
    pub outputs: HashMap<String, f32>,

    /// The time needed to craft the recipe.
    pub craft_time: f32,

    /// The conditions that must be met to craft the recipe.
    pub conditions: Option<RecipeConditions>,

    /// The amount of [`Energy`] produced by making this recipe, if any.
    ///
    /// This is only relevant to living structures.
    pub energy: Option<Energy>,
}

impl From<RawRecipeData> for RecipeData {
    fn from(raw: RawRecipeData) -> Self {
        Self {
            inputs: raw
                .inputs
                .into_iter()
                .map(|(item_name, count)| ItemCount {
                    item_id: Id::from_name(item_name),
                    count,
                })
                .collect(),
            outputs: RecipeOutput::from_raw(raw.outputs),
            craft_time: Duration::from_secs_f32(raw.craft_time),
            conditions: raw.conditions.unwrap_or_default(),
            energy: raw.energy,
        }
    }
}

impl RecipeData {
    /// Are the conditions to craft this recipe met?
    pub(crate) fn satisfied(&self, workers: u8, total_light: &TotalLight) -> bool {
        self.conditions.satisfied(workers, total_light)
    }

    /// An inventory with empty slots for all of the inputs of this recipe.
    pub(crate) fn input_inventory(&self, item_manifest: &ItemManifest) -> InputInventory {
        let mut inventory = Inventory::new(self.inputs.len(), None);
        for item_count in &self.inputs {
            inventory.add_empty_slot(item_count.item_id, item_manifest);
        }
        InputInventory { inventory }
    }

    /// An inventory with empty slots for all of the outputs of this recipe.
    pub(crate) fn output_inventory(&self, item_manifest: &ItemManifest) -> OutputInventory {
        let mut inventory = Inventory::new(self.outputs.len(), None);
        for item_id in self.outputs.item_ids() {
            inventory.add_empty_slot(item_id, item_manifest);
        }
        OutputInventory { inventory }
    }

    /// The number of workers this recipe needs to be crafted at all.
    pub(crate) fn workers_required(&self) -> u8 {
        self.conditions.workers_required
    }

    /// Does this recipe need workers to produce?
    pub(crate) fn needs_workers(&self) -> bool {
        self.conditions.workers_required > 0
    }

    /// The pretty formatting of this type
    pub(crate) fn display(&self, item_manifest: &ItemManifest) -> String {
        let input_strings: Vec<String> = self
            .inputs
            .iter()
            .map(|input| input.display(item_manifest))
            .collect();
        let input_str = input_strings.join(", ");

        let output_strings: Vec<String> = self
            .outputs
            .item_ids()
            .iter()
            .map(|output_id| item_manifest.name(*output_id).to_string())
            .collect();
        let output_str = output_strings.join(", ");

        let duration_str = format!("{:.2}", self.craft_time.as_secs_f32());

        let condition_str = if self.conditions == RecipeConditions::default() {
            String::new()
        } else {
            format!("\nwhen {}", self.conditions)
        };

        format!("[{input_str}] -> [{output_str}] | {duration_str} s{condition_str}")
    }
}

/// The environmental conditions needed for work to be done on a recipe.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default)]
pub struct RecipeConditions {
    /// The number of workers required to advance this recipe.
    pub workers_required: u8,
    /// The range of light levels that are acceptable for this recipe.
    pub allowable_light_range: Option<Threshold<Illuminance>>,
}

impl Display for RecipeConditions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.workers_required > 0 {
            write!(f, "Workers: {}", self.workers_required)?;
        }
        if let Some(range) = &self.allowable_light_range {
            write!(f, "Light: {}", *range)?;
        }
        Ok(())
    }
}

impl RecipeConditions {
    /// Creates a new [`RecipeConditions`].
    pub const fn new(workers_required: u8, allowable_light_range: Threshold<Illuminance>) -> Self {
        Self {
            workers_required,
            allowable_light_range: Some(allowable_light_range),
        }
    }

    /// Are the conditions to craft this recipe met?
    fn satisfied(&self, workers: u8, total_light: &TotalLight) -> bool {
        let work_satisfied = self.workers_required == 0 || workers >= self.workers_required;
        let light_satisfied = self
            .allowable_light_range
            .as_ref()
            .map_or(true, |range| range.contains(total_light.illuminance()));

        work_satisfied && light_satisfied
    }
}

/// A viable range of a value.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Threshold<T: PartialOrd> {
    /// The minimum value of the range.
    min: T,
    /// The maximum value of the range.
    max: T,
}

impl<T: PartialOrd> Threshold<T> {
    /// Creates a new [`Threshold`].
    pub fn new(min: T, max: T) -> Self {
        assert!(min <= max);

        Self { min, max }
    }

    /// Returns true if the value is within the threshold.
    fn contains(&self, value: T) -> bool {
        self.min <= value && value <= self.max
    }
}

impl<T: Display + PartialOrd> Display for Threshold<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} - {}", self.min, self.max)
    }
}

/// The [`RecipeManifest`] as seen in the manifest file.
#[derive(Debug, Clone, Serialize, Deserialize, TypeUuid, PartialEq)]
#[uuid = "c711b30c-c3ff-4b86-92d0-f1aff2ec7818"]
pub struct RawRecipeManifest {
    /// The data for each item.
    pub recipes: HashMap<String, RawRecipeData>,
}

impl IsRawManifest for RawRecipeManifest {
    const EXTENSION: &'static str = "recipe_manifest.json";

    type Marker = Recipe;
    type Data = RecipeData;

    fn process(&self) -> Manifest<Self::Marker, Self::Data> {
        let mut manifest = Manifest::new();

        for (raw_id, raw_data) in self.recipes.clone() {
            let data = raw_data.into();

            manifest.insert(raw_id, data)
        }

        manifest
    }
}
