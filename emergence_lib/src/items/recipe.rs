//! Instructions to craft items.

use std::time::Duration;

use crate::{
    asset_management::manifest::{Id, ItemManifest},
    organisms::energy::Energy,
    structures::crafting::{InputInventory, OutputInventory},
};

use super::{inventory::Inventory, ItemCount};

/// A recipe to turn a set of items into different items.
#[derive(Debug, Clone)]
pub(crate) struct RecipeData {
    /// The inputs needed to craft the recipe.
    inputs: Vec<ItemCount>,

    /// The outputs generated by crafting.
    outputs: Vec<ItemCount>,

    /// The time needed to craft the recipe.
    craft_time: Duration,

    /// Is work by units needed to advance this recipe?
    work_required: bool,

    /// The amount of [`Energy`] produced by making this recipe, if any.
    ///
    /// This is only relevant to living structures.
    energy: Option<Energy>,
}

impl RecipeData {
    /// Create a new recipe with the given inputs, outputs and craft time.
    pub(crate) fn new(
        inputs: Vec<ItemCount>,
        outputs: Vec<ItemCount>,
        craft_time: Duration,
        work_required: bool,
        energy: Option<Energy>,
    ) -> Self {
        Self {
            inputs,
            outputs,
            craft_time,
            work_required,
            energy,
        }
    }

    /// The inputs needed to craft the recipe.
    pub(crate) fn inputs(&self) -> &Vec<ItemCount> {
        &self.inputs
    }

    /// The outputs generated by crafting.
    pub(crate) fn outputs(&self) -> &Vec<ItemCount> {
        &self.outputs
    }

    /// The time needed to craft the recipe.
    pub(crate) fn craft_time(&self) -> Duration {
        self.craft_time
    }

    /// Is work from units needed to advance this recipe?
    pub(crate) fn work_required(&self) -> bool {
        self.work_required
    }

    /// An inventory with empty slots for all of the inputs of this recipe.
    pub(crate) fn input_inventory(&self, item_manifest: &ItemManifest) -> InputInventory {
        let mut inventory = Inventory::new(self.inputs.len());
        for item_count in &self.inputs {
            inventory.add_empty_slot(item_count.item_id, item_manifest);
        }
        InputInventory { inventory }
    }

    /// An inventory with empty slots for all of the outputs of this recipe.
    pub(crate) fn output_inventory(&self, item_manifest: &ItemManifest) -> OutputInventory {
        let mut inventory = Inventory::new(self.outputs.len());
        for item_count in &self.outputs {
            inventory.add_empty_slot(item_count.item_id, item_manifest);
        }
        OutputInventory { inventory }
    }

    /// The amount of energy produced by crafting the recipe, if any.
    pub(crate) fn energy(&self) -> &Option<Energy> {
        &self.energy
    }

    /// The pretty formatting of this type
    pub(crate) fn display(&self, item_manifest: &ItemManifest) -> String {
        let input_strings: Vec<String> = self
            .inputs
            .iter()
            .map(|input| input.display(item_manifest))
            .collect();
        let input_str = input_strings.join(", ");

        let output_strings: Vec<String> = self
            .outputs
            .iter()
            .map(|output| output.display(item_manifest))
            .collect();
        let output_str = output_strings.join(", ");

        let duration_str = format!("{:.2}", self.craft_time().as_secs_f32());

        format!("[{input_str}] -> [{output_str}] | {duration_str} s")
    }
}

// TODO: Remove this once we load recipes from asset files
impl RecipeData {
    /// An acacia plant producing leaves.
    pub(crate) fn acacia_leaf_production() -> Self {
        RecipeData::new(
            Vec::new(),
            vec![ItemCount::one(Id::from_name("acacia_leaf"))],
            Duration::from_secs(3),
            false,
            Some(Energy(20.)),
        )
    }

    /// A leuco mushroom processing acacia leaves
    pub(crate) fn leuco_chunk_production() -> Self {
        RecipeData::new(
            vec![ItemCount::one(Id::from_name("acacia_leaf"))],
            vec![ItemCount::one(Id::from_name("leuco_chunk"))],
            Duration::from_secs(2),
            false,
            Some(Energy(40.)),
        )
    }

    /// An ant hive producing eggs.
    pub(crate) fn ant_egg_production() -> Self {
        RecipeData::new(
            vec![ItemCount::one(Id::from_name("leuco_chunk"))],
            vec![ItemCount::one(Id::from_name("ant_egg"))],
            Duration::from_secs(5),
            false,
            None,
        )
    }

    /// An ant hive producing eggs.
    pub(crate) fn hatch_ants() -> Self {
        RecipeData::new(
            vec![ItemCount::one(Id::from_name("ant_egg"))],
            vec![],
            Duration::from_secs(10),
            true,
            None,
        )
    }
}
